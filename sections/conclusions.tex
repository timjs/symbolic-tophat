% !TEX root=../main.tex

\section{Conclusion}

\label{sec:conclusion}

In this paper, we have demonstrated how to apply symbolic execution to \TOPHAT to verify individual programs.
We have developed both a formal system and an implementation of a symbolic execution semantics.
Our approach has been validated by proving the formal system correct, and by running the implementation on example programs.
For these two example programs, a subsidy request workflow and a flight booking workflow, we have verified that they adhere to their specifications.


\subsection{Future work}

There are many ways in which we would like to continue this line of work.

First, we believe that more can be done with symbolic execution.
Our current approach only allows proving predicates over task results and input values.
We cannot, however, prove properties that depend on the order of the inputs.
Since the symbolic execution currently returns a list of symbolic inputs, we think this extension is feasible.

Second, our symbolic execution only applies to \TOPHAT.
We would like to see if we can fit it to iTasks.
This poses several challenges.
iTasks does not have a formal semantics in the sense that \TOPHAT has.
The current implementation in Clean is the closest thing available to a formal specification.
There are also a few language features in iTasks that are not covered by \TOPHAT, for example loops.

Third, we would like to apply different kinds of analyses altogether.
Can a certain part of the program be reached?
Does a certain property hold at every point in the program?
Are two programs equal? And what does it mean for two programs to be equal?
We think that these properties require a different approach.
